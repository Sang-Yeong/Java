# 10. 오류처리하기
## 디버깅
> - 디버거를 사용해 프로그램의 오류를 쉽게 감지하고 진단할 수 O
> - 디버거는 중단점을 설정하여 프로그램의 실행을 제어 할 수 O
> - 문장 단위 or 변수의 값을 살펴볼 수 O


## 예외 처리
> - 에러: 프로그램이 실행 중, 어떤 원인에 의해 오작동하거나 비정상적으로 종료되는 경우
> 	- 컴파일 에러: 컴파일 시 발생하는 에러(ex. 문법)
> 	- 런타임 에러: 실행 도중에 발생하는 에러
> 		- 예외(Exception): 수습 가능한 오류, **예외처리**를 통해 대비하면 비정상적인 프로그램 방지 O
> 		- 에러(Error): 메모리 부족과 같은 심각한 오류, 발생시 프로그램 종료


> - 오류 발생 시, 오류를 사용자에게 알려주고 모든 데이터를 저장하게 한 후에 사용자가 우아하게(gracefully) 프로그램을 종료할 수 있도록 하기 위함이다.
> - 예외(exception): 잘못된 코드, 부정확한 데이터, 예외적인 상황에 의하여 발생하는 오류
> ```java
> try{
> 	// 예외가 발생할 수 있는 코드
> }
> catch(예외종류 참조변수){
> 	// 예외를 처리하는 코드
> }
> catch(예외종류 참조변수){
> 	// 예외를 처리하는 코드
> }
> finally{
> 	// try블록이 끝나면 무조건 실행되는 코드
> 	// 생략 가능
> 	out.close();	// 예외가 발생하더라도 확실하게 자원이 반납된다.
> }
> ```
>   - 예외처리 실행 과정
> 	  - try문에서 예외발생 -> 클래스에 인스턴스가 만들어진다.
> 	  - 위에서 만들어진 인스턴스와 catch문에서 선언된 참조변수가 instanceof 연산자로 true인 catch문을 찾게된다.
>   
> 	- catch문 괄호안에 선언된 참조변수는 해당 catch문에서만 유효하기 때문에 다른 catch문에서 반복 사용이 가능하다.
> 	- 중첩 try-catch문 사용이 가능하다.
>
> - 예외의 종류
> 	- Objct - Throwable
>
> 			- Error: 너무 심각해서 할 수 있는 방법이 없음 -> 통과
>
> 				- ...
>
> 			- Exception
>
> 					- ...
>
> 					- RuntimeException: 프로그래밍 버그이므로 스스로 고쳐야 함 -> 통과
>
> 			Error나 RuntimeException이 아닌 예외: 반드시 처리해야 함 -> 검사
> - 다형성과 예외
> 	- 상위 클래스의 참조변수는 하이 클래스의 객체를 참조할 수 O
> 	- catch블록에서 예외잡을 때 유용 -> catch문의 예외의 하위 클래스를 모두 잡을 수 있다.
>   - catch문을 여러개 사용할 경우, 앞에 위치한 catch문의 예외가 뒤에오는 catch문의 예외보다 자식이어야 한다.


## 예외와 메소드
> - throws사용 -> 다른 메소드에게 예외 처리를 맡길 수 O
> - 예외를 처리하는 절차
> 	- 메소드 안에서 예외가 발생하는 런타임 시스템은 그 메소드 안에 예외처리기가 있는지 살핀다.
> 	- if 그 자리에 예외 처리기X; 호출 스택(call stack)에 있는 상위 메소드를 조사한다.


## 예외 생성하기
> - 예외는 throw문장으로 생성된다.
> 	- throw문장은 Throwable 객체, 하나의 인수만을 요구한다.
> 	```java
> 	throw someThrowableObject;
> 	```


## 예외 처리의 장점
> - 예외 처리의 장점
> 	- 오류 처리 코드를 정산적인 코드와 분리 할 수 O


## 단언
> - 단언(assertions): 프로그래머가 현재 시점에서 믿고 있는 내용을 다시 한 번 확인할 때 사용.
> ```java
> assert 조건;
> assert 조건: 수식;
> ```


## 로깅
> - 로깅(logging): 어딘가에 계속하여 기록을 남기는 것.
> - 애플리케이션 -> 로깅 컨포넌트 -> DB/ 파일/ 네트워크상의 저장소
